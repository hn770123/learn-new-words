# 第1章：Gitで雰囲気で使ってる系

毎日のように`git`コマンドを叩いているエンジニアは多い。しかし「マージとリベースの違いは？」と聞かれて、自信を持って答えられる人はどれくらいいるだろうか。

本章では、Gitにまつわる「雰囲気で使ってる」用語を取り上げる。これらを正しく理解すれば、チーム内でのGit議論で黙り込む必要がなくなる。少なくとも、黙り込む頻度は減るはずである。

---

## マージとリベース

### 雰囲気での理解

「どっちもブランチを統合するやつでしょ？結果同じだし、好みの問題では？」

### 実際の違い

結果が「同じ」というのは、最終的なコードの状態という意味では正しい。しかしGitにおいて重要なのは、コードの状態だけではなく「歴史」である。

**マージ（merge）** は、2つのブランチの歴史を合流させる。川の支流が本流に合流するイメージだ。合流地点には「マージコミット」という特別なコミットが作られ、「ここで2つの流れが1つになった」という記録が残る。

```
      A---B---C  feature
     /         \
D---E---F---G---H  main (Hがマージコミット)
```

**リベース（rebase）** は、ブランチの「起点」を付け替える操作である。「re-base」、つまり「baseを再設定する」という意味だ。featureブランチで行った変更を、まるで最初からmainの最新地点から始めていたかのように書き換える。

```
Before:
      A---B---C  feature
     /
D---E---F---G  main

After rebase:
              A'--B'--C'  feature
             /
D---E---F---G  main
```

リベース後のA'、B'、C'は、元のA、B、Cと同じ変更内容だが、異なるコミットである。コミットハッシュも変わる。つまり、歴史を「書き換えている」のだ。

### なぜこれが重要なのか

マージは歴史を保存し、リベースは歴史を書き換える。

チームで作業する場合、すでにリモートにプッシュしたコミットをリベースすると、他のメンバーの手元にある歴史と食い違いが生じる。これは「force push」という禁断の呪文を唱えない限り解決できず、唱えた場合はチームメンバーから冷たい視線を浴びることになる。

筆者はかつて、共有ブランチをリベースしてforce pushし、3人の同僚の午後を台無しにしたことがある。彼らはその日、筆者にコーヒーをおごらなかった。当然である。

### 使い分けの指針

- **マージ**：共有ブランチへの統合、歴史を残したい場合
- **リベース**：ローカルでの作業整理、きれいな直線的履歴を作りたい場合

「結果同じ」という理解は、料理で「焼くも煮るも結果的に火を通すから同じ」と言っているようなものである。

---

## フェッチとプル

### 雰囲気での理解

「リモートから取ってくるやつ。pullの方がよく使うから、fetchはpullの古いバージョン的な？」

### 実際の違い

**フェッチ（fetch）** は、リモートリポジトリの情報をローカルにダウンロードするが、現在の作業ブランチには何も影響を与えない。リモートの状態を「見に行く」だけの操作である。

**プル（pull）** は、フェッチ＋マージ（またはフェッチ＋リベース）である。つまり、リモートの情報を取得した上で、現在のブランチに統合まで行う。

```
git fetch origin main    # リモートの情報を取得（作業には影響なし）
git merge origin/main    # 取得した情報を現在のブランチにマージ

# 上の2行は下の1行と同じ
git pull origin main
```

### なぜフェッチだけする場面があるのか

プルは便利だが、「取得」と「統合」を一度に行うため、何が起きたのか把握しにくいことがある。

フェッチだけ行えば、統合前にリモートの変更内容を確認できる。

```bash
git fetch origin main
git log HEAD..origin/main  # リモートにあって手元にないコミットを確認
git diff HEAD origin/main  # 差分を確認
# 内容を確認してから...
git merge origin/main      # 納得したらマージ
```

本番環境にデプロイする前に、まず内容を確認してからデプロイするのと同じ発想である。もっとも、確認せずにデプロイして痛い目を見た経験がないエンジニアは、まだ十分な経験を積んでいないだけかもしれない。

### 覚え方

- **fetch**：偵察部隊。情報を持ち帰るが、攻撃はしない
- **pull**：突撃部隊。情報取得と攻撃（統合）を同時に行う

---

## チェリーピック

### 雰囲気での理解

「さくらんぼ？なんか特定のコミットだけ取ってくるやつ？」

### 正確な理解

**チェリーピック（cherry-pick）** は、特定のコミットの変更内容を、現在のブランチに適用する操作である。

「さくらんぼ狩り」で、木全体ではなく美味しそうな実だけを選んで摘むように、ブランチ全体ではなく特定のコミットだけを選んで持ってくる。

```bash
# developブランチの特定のコミット（abc123）だけをmainに持ってくる
git checkout main
git cherry-pick abc123
```

### 典型的な使用場面

1. **緊急のバグ修正**：developで修正したバグを、リリースブランチにも適用したい
2. **機能の部分的な取り込み**：大きな機能ブランチから、完成した一部だけを先に取り込みたい
3. **誤ったブランチへのコミット**：mainにコミットすべき内容をdevelopにしてしまった場合の救済

### 注意点

チェリーピックは同じ変更内容を異なるコミットとして複製する。つまり、後でブランチをマージするときにコンフリクトが発生する可能性がある。同じ変更が2つの異なるコミットとして存在するからだ。

頻繁にチェリーピックが必要な状況は、ブランチ戦略に問題があるサインかもしれない。さくらんぼは時々摘むから楽しいのであって、毎日摘んでいたら農作業である。

---

## スカッシュ

### 雰囲気での理解

「コミットを押しつぶす？まとめるってこと？」

### 正確な理解

**スカッシュ（squash）** は、複数のコミットを1つのコミットにまとめる操作である。「squash」は英語で「押しつぶす」という意味だ。

開発中は試行錯誤で細かいコミットが大量に生まれることがある。

```
abc123 typoを修正
def456 やっぱり元に戻す
ghi789 もう一度修正
jkl012 レビュー指摘対応
mno345 レビュー指摘対応その2
```

このまま履歴に残すと、後から見た人は「この人は何をやっていたのか」と困惑する。スカッシュを使えば、これらを1つの意味のあるコミットにまとめられる。

```bash
git rebase -i HEAD~5  # 直近5コミットを対話的にリベース
```

エディタで`pick`を`squash`（または`s`）に変更すると、そのコミットは直前のコミットに統合される。

### マージ時のスカッシュ

GitHubやGitLabでは、プルリクエストをマージする際に「Squash and merge」というオプションがある。これを使うと、プルリクエストの全コミットが1つにまとまってマージされる。

```
# Squash and merge前
feature: A---B---C---D---E

# Squash and merge後（mainには1コミットとして入る）
main: ...---F (A〜Eの変更がすべて含まれる)
```

### 使いどころ

- プルリクエストの履歴をきれいにまとめたい
- 「WIP」「fix typo」「試しにやってみた」系のコミットを隠したい
- mainブランチの履歴を機能単位で整理したい

ただし、スカッシュしすぎると細かい変更履歴が失われる。バグが混入した際に「このコミットが原因」と特定するのが難しくなることもある。押しつぶすのは、押しつぶして良いものだけにすべきである。

---

## ステージング

### 雰囲気での理解

「`git add`するとステージングされる。ステージングエリアに行く。それで、コミットできるようになる」

### もう少し深い理解

Gitには3つの領域がある。

1. **ワーキングディレクトリ（Working Directory）**：実際にファイルを編集する場所
2. **ステージングエリア（Staging Area）**：次のコミットに含める変更を準備する場所。「インデックス」とも呼ばれる
3. **リポジトリ（Repository）**：コミットされた履歴が保存される場所

```
[ワーキングディレクトリ] --git add--> [ステージングエリア] --git commit--> [リポジトリ]
```

### なぜステージングエリアが必要なのか

「変更したファイルを全部コミットするなら、ステージングエリアは不要では？」という疑問は正当である。

ステージングエリアの価値は、**コミットの粒度を制御できる**ことにある。

例えば、1つのファイルを編集中に2つの独立した変更を行ったとする。バグ修正とリファクタリングが混在している状態だ。

```bash
git add -p  # パッチモードで変更の一部だけをステージング
```

これにより、1つのファイルの変更でも、一部だけをステージングして「バグ修正」としてコミットし、残りを「リファクタリング」として別コミットにできる。

### ステージングを経由しないコミット

```bash
git commit -a -m "メッセージ"
```

`-a`オプションは、変更があるすべての追跡済みファイルを自動的にステージングしてコミットする。便利だが、何をコミットしているのか意識しなくなる危険がある。

筆者は`git commit -a`で`.env`ファイルをコミットしてしまい、慌てて履歴から抹消したことがある。APIキーがGitHubに公開されるまでの時間は、体感で数時間だが実際は15分だった。

---

## HEAD、origin、upstream

### 雰囲気での理解

「HEADは今いるところ？originはリモート？upstreamは...フォーク元？」

雰囲気の理解としては及第点である。しかし、もう少し正確に理解しておこう。

### HEAD

**HEAD**は、現在チェックアウトしているコミットを指すポインタである。通常はブランチ名を経由して特定のコミットを指している。

```
HEAD -> main -> abc123（コミット）
```

`git checkout`でブランチを切り替えると、HEADが指す先が変わる。

```bash
git checkout feature
# HEAD -> feature -> def456（コミット）
```

#### detached HEAD状態

ブランチではなく、直接コミットをチェックアウトすると「detached HEAD」状態になる。

```bash
git checkout abc123  # コミットを直接チェックアウト
# HEAD -> abc123（ブランチを経由しない）
```

この状態で新しいコミットを作ると、どのブランチにも属さない宙ぶらりんのコミットが生まれる。ブランチを切り替えると、そのコミットは迷子になる。正確には、ガベージコレクションによって一定期間後に消滅する。

### origin

**origin**は、リモートリポジトリのデフォルトの名前である。`git clone`すると、クローン元のリモートリポジトリに自動的に「origin」という名前が付けられる。

```bash
git remote -v
# origin  https://github.com/user/repo.git (fetch)
# origin  https://github.com/user/repo.git (push)
```

「origin」という名前に特別な意味はない。慣習的にそう呼ばれているだけで、`my-remote`でも`production`でも好きな名前を付けられる。ただし、慣習に逆らうと同僚が混乱する。

### upstream

**upstream**は2つの文脈で使われる。

1. **フォーク元のリポジトリ**：オープンソースプロジェクトをフォークした場合、フォーク元を`upstream`と呼ぶことが多い

```bash
git remote add upstream https://github.com/original/repo.git
```

2. **追跡ブランチの設定**：ローカルブランチがどのリモートブランチを追跡するかの設定

```bash
git branch --set-upstream-to=origin/main main
```

### 整理

| 用語 | 意味 |
|------|------|
| HEAD | 現在チェックアウトしているコミットへのポインタ |
| origin | クローン元のリモートリポジトリ（慣習的な名前） |
| upstream | フォーク元のリモート、または追跡対象のリモートブランチ |

これらは「誰が誰やら問題」を引き起こしやすいが、本質的には「何がどこを指しているか」というポインタの話である。

---

## fast-forward

### 雰囲気での理解

「早送り？動画の早送りみたいに速いマージってこと？」

### 正確な理解

**fast-forward**は、マージの一種だが、新しいマージコミットを作らないマージである。

条件がある。マージ先のブランチが、マージ元のブランチの直接の祖先である場合にのみ発生する。

```
Before:
main:    A---B
              \
feature:       C---D---E

mainをfeatureにマージしようとすると...
mainはfeatureの祖先（BはCの親）なので、fast-forwardが可能

After:
main:    A---B---C---D---E
              (mainのポインタが移動しただけ)
```

この場合、main側で新しい変更がないため、単にmainのポインタをfeatureの先端に「早送り」するだけでマージが完了する。マージコミットは作られない。

### fast-forwardできない場合

```
main:    A---B---F---G
              \
feature:       C---D---E

mainにも新しいコミット（F、G）がある。
mainはfeatureの直接の祖先ではないので、fast-forward不可。
通常のマージコミットが必要。
```

### なぜ気にする必要があるのか

`git merge`や`git pull`のデフォルト動作は、fast-forward可能ならfast-forwardし、不可能なら通常のマージを行う。

これを制御するオプションがある。

```bash
git merge --ff-only feature   # fast-forwardできる場合のみマージ。できなければ中止
git merge --no-ff feature     # fast-forward可能でも必ずマージコミットを作る
```

`--no-ff`は、機能ブランチをマージした記録を明示的に残したい場合に使う。「この範囲のコミットが1つの機能として開発された」という情報が履歴に残る。

プロジェクトによっては「マージは必ず`--no-ff`で」というルールを設けていることがある。fast-forwardの概念を知らないと、このルールの意味が理解できない。

---

## Git操作、本当は何が起きてるの？

本章で扱った用語を図で整理してみよう。

```
┌─────────────────────────────────────────────────────────────┐
│                        リモートリポジトリ                      │
│                     (origin / upstream)                      │
└─────────────────────────────────────────────────────────────┘
                    │                    ▲
                    │ fetch              │ push
                    │ (情報取得)          │ (送信)
                    ▼                    │
┌─────────────────────────────────────────────────────────────┐
│              ローカルリポジトリ (.git)                         │
│                                                             │
│   HEAD → main → コミットA → コミットB → ...                   │
│                                                             │
│   【merge】別ブランチの変更を統合（マージコミット作成）           │
│   【rebase】コミットの起点を付け替え（履歴書き換え）             │
│   【cherry-pick】特定コミットだけを適用                        │
│   【squash】複数コミットを1つにまとめる                        │
│   【fast-forward】ポインタ移動だけでマージ完了                  │
└─────────────────────────────────────────────────────────────┘
                    │                    ▲
                    │ checkout           │ commit
                    ▼                    │
┌─────────────────────────────────────────────────────────────┐
│                   ステージングエリア                          │
│                      (インデックス)                          │
│                                                             │
│        次のコミットに含める変更を準備する場所                    │
└─────────────────────────────────────────────────────────────┘
                    │                    ▲
                    │ checkout           │ add
                    ▼                    │
┌─────────────────────────────────────────────────────────────┐
│                  ワーキングディレクトリ                        │
│                                                             │
│             実際にファイルを編集する場所                        │
└─────────────────────────────────────────────────────────────┘
```

---

## まとめ

本章で扱った用語をおさらいする。

| 用語 | 一言で言うと |
|------|------------|
| マージ | 歴史を合流させる |
| リベース | 歴史を書き換えて直線にする |
| フェッチ | リモートの情報を取得（統合しない） |
| プル | フェッチ＋マージ（または＋リベース） |
| チェリーピック | 特定コミットだけを摘み取る |
| スカッシュ | 複数コミットを1つに押しつぶす |
| ステージング | コミット前の準備エリア |
| HEAD | 現在位置を指すポインタ |
| origin | リモートリポジトリの慣習的な名前 |
| upstream | フォーク元、または追跡対象 |
| fast-forward | ポインタ移動だけで完了するマージ |

これらの用語を正確に理解していれば、次にチームでGitの議論になったとき、少なくとも「分かったフリ」から「本当に分かっている」側に回れるはずである。

ただし、本当に分かっている人ほど「Gitは難しい」と言うものである。なぜなら、ここで説明したのは入口にすぎないからだ。`reflog`、`bisect`、`worktree`といった道具たちが、その先で待っている。

本章の内容を完全に理解したら、次は実際に手を動かして試してみることを勧める。テスト用のリポジトリを作り、思う存分マージしたりリベースしたりすればよい。壊しても誰も怒らない環境で練習するのが、最も効率的な学習方法である。

本番リポジトリで練習してはいけない。これは念のために言っているのではなく、筆者自身への戒めでもある。
