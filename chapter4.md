# 第4章:「アーキテクチャで雰囲気で使ってる」系

## はじめに:設計レビューという名の公開処刑

設計レビューの会議室。あなたは自信満々で図を映しながら説明する。

「このサービスは**疎結合**で設計していて、**ステートレス**なので、**エンドポイント**に**ペイロード**を送ると…」

先輩エンジニアの眉がピクリと動く。

「で、その疎結合って具体的にどういう意味で使ってる?」

……あれ?疎結合って、なんかいい感じに分離されてるってことだよね?違うの?

アーキテクチャ用語は、**使うと賢く見えるが、突っ込まれると詰む**という恐ろしい性質を持っている。しかも、みんな雰囲気で使っているくせに、指摘する側に回ると急に厳しくなるという不思議な現象が起きる。

この章では、設計の話で飛び交う「なんとなく知ってるけど説明できない」用語たちを、あなたの尊厳を守るために徹底解説する。

---

## 疎結合と密結合:離婚率の高さで語るな

### 雰囲気使用例

「このモジュール、密結合になってるから疎結合にリファクタリングしましょう」

**質問:** で、どう疎結合にするの?
**あなた:** え…と…インターフェース…的な…?

### 正しい理解

**密結合(Tight Coupling)**とは、コンポーネント同士が相手の内部実装に強く依存している状態。一方が変更されると、もう一方も変更が必要になる。まるで「彼女がLINEの文面を変えたら、俺の返信パターンも全部変えないといけない」みたいな関係だ。

**疎結合(Loose Coupling)**とは、コンポーネント間のインターフェース(契約)だけを知っていて、内部実装は知らない状態。「APIで決められた形式でデータくれればいいよ、中身がPythonだろうがGoだろうが知らん」という健全な距離感。

```python
# 密結合の例:「相手の内部を直接触りまくる」
class OrderService:
    def create_order(self, user_id):
        db = MySQLDatabase()  # 具体的なDB実装に依存
        db.host = "localhost"  # 内部の詳細を知りすぎ
        db.connect()
        # ...

# 疎結合の例:「インターフェース越しに会話する」
class OrderService:
    def __init__(self, database: DatabaseInterface):
        self.db = database  # 抽象に依存(依存性の注入)

    def create_order(self, user_id):
        self.db.save(order)  # 実装の詳細は知らない
```

### 実践での判断基準

- **密結合かどうかのチェック:** 「このクラスが使ってる別のクラスを、テストでモックに差し替えられる?」→差し替えられないなら密結合
- **疎結合にすべきかの判断:** 変更が頻繁に起きる境界、外部サービスとの境界、テストしたい箇所は疎結合に。それ以外は無理に疎結合にすると逆に複雑になる

### よくある勘違い

「疎結合=ファイルが分かれてる」←**違います**。100個のファイルに分かれていても、お互いの内部実装を直接参照していれば密結合です。物理的な距離と、論理的な結合度は別物。

### 使える一言

「この部分、インターフェースを挟んで依存性を逆転させれば、テスタビリティも上がりますね」←これで設計レビューは乗り切れる

---

## ステートレスとステートフル:記憶喪失か、執念深いか

### 雰囲気使用例

「このAPI、ステートレスだから水平スケールできます!」

**質問:** セッション情報はどうするの?
**あなた:** あっ…それは…Redis に…?(本当にステートレスなのか?)

### 正しい理解

**ステートレス(Stateless)**:「前回会ったときの話?覚えてないけど」というスタンス。サーバーはリクエストごとに必要な情報を全部受け取り、処理が終わったら忘れる。次のリクエストが同じクライアントから来ても覚えていない。

**ステートフル(Stateful)**:「前回、◯◯って言ってたよね?」と覚えているスタンス。サーバー側でセッションやコネクションの状態を保持し、継続的な会話を可能にする。

```http
# ステートレスの例:毎回身分証明書を見せる
GET /api/user/profile
Headers:
  Authorization: Bearer eyJhbGc...  # ←毎回トークンを持ってくる

# ステートフルの例:「前回ログインした人だよね?」で通す
GET /api/user/profile
Headers:
  Cookie: session_id=abc123  # サーバー側でセッション情報を保持
```

### なぜステートレスがもてはやされるのか

サーバーが状態を持たないと、**どのサーバーインスタンスでリクエストを処理しても同じ結果**になる。つまり:

- **水平スケーリングが簡単:** サーバー10台に増やしても、ロードバランサーで適当に振り分ければOK
- **障害復旧が楽:** サーバーが落ちても、別のサーバーで処理すればいいだけ
- **クラウド時代と相性抜群:** インスタンスを増減させやすい

一方、ステートフルだと「セッション情報持ってるサーバー」に固定で送る必要が出てきて(スティッキーセッション)、面倒が増える。

### 現実の妥協点

「完全にステートレス!」と言いつつ、実際は:

- JWTトークンにユーザー情報を埋め込む(クライアントに状態を持たせる)
- Redis/Memcachedで状態を外部に逃がす(サーバー自体はステートレス)
- データベースに状態を保存(永続化された状態)

これらは「**サーバープロセス自体は状態を持たない**」という意味でステートレス扱い。言葉遊びっぽいが、スケールの観点では重要な違い。

### よくある勘違い

「ステートレス=データベースを使わない」←**違います**。DBは外部の永続層。サーバープロセスのメモリに状態を持たなければステートレス。

### 使える一言

「セッション管理をRedisに外出しすることで、アプリケーション層をステートレスに保ちつつ、ユーザー体験は維持できますね」

---

## イミュータブル:「変更できない」が生む平和

### 雰囲気使用例

「このデータ、イミュータブルにしましょう」

**質問:** なんで?
**あなた:** えっと…安全…だから…?(なぜ安全なのか説明できない)

### 正しい理解

**イミュータブル(Immutable)**は「不変」という意味。**一度作ったら変更できないオブジェクト**のこと。変更したければ、新しいオブジェクトを作る。

```javascript
// ミュータブル(可変):元のデータが変わる
const user = { name: "太郎", age: 25 };
user.age = 26;  // ←元のオブジェクトが変更される

// イミュータブル(不変):新しいオブジェクトを作る
const user = { name: "太郎", age: 25 };
const updatedUser = { ...user, age: 26 };  // ←新しいオブジェクト
// 元のuserは { name: "太郎", age: 25 } のまま
```

### なぜイミュータブルが良いのか

**1. バグの温床を断つ**

```javascript
// ミュータブルの恐怖
function processUser(user) {
    user.age += 1;  // うっかり元のデータを変更
    return user;
}

const original = { name: "太郎", age: 25 };
const processed = processUser(original);
console.log(original.age);  // 26 ←え、元のデータ変わってる!?
```

イミュータブルなら、関数内でどんな処理をしようが**元のデータは絶対に変わらない**。安心感がすごい。

**2. 並行処理での事故防止**

複数のスレッドが同じデータを触るとき、イミュータブルなら**誰も変更できない**ので、ロックが不要。Javaの`String`がイミュータブルなのはこのため。

**3. 変更履歴の追跡が簡単**

Reactの状態管理やGitのコミットがイミュータブルなのは、「前の状態」と「新しい状態」を両方保持できるから。

### デメリット:メモリと速度

新しいオブジェクトを作りまくるので、メモリを食う。巨大な配列の1要素を変えるだけで配列全体をコピー…とかやると遅い。だから現実には「構造共有」などの技法で最適化する(ClojureやImmutable.jsなど)。

### よくある勘違い

「`const`を使えばイミュータブル」←**半分正解、半分不正解**。`const`は**再代入を禁止する**だけで、オブジェクトの中身は変えられる。

```javascript
const user = { age: 25 };
user.age = 26;  // ←これは可能(中身は変えられる)
user = { age: 30 };  // ←これはエラー(再代入は不可)
```

本当にイミュータブルにするには`Object.freeze()`やImmutable.jsなどを使う。

### 使える一言

「状態の変更履歴を追跡しやすくするため、イミュータブルなデータ構造でリデューサーを実装しましょう」←Redux使ってる感が出る

---

## ポリモーフィズム:「多態性」って言われても

### 雰囲気使用例

「ここはポリモーフィズムを活用して…」

**質問:** 具体的にどう実装する?
**あなた:** インターフェース…継承…オーバーライド…?(全部ごちゃまぜ)

### 正しい理解

**ポリモーフィズム(Polymorphism)**は直訳すると「多態性」。**同じインターフェースで、異なる実装を呼び出せる**こと。

要するに「**同じメソッド名で呼び出すけど、中身は違う処理**」ができる仕組み。

```python
# 動物インターフェース
class Animal:
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "ワン!"

class Cat(Animal):
    def speak(self):
        return "ニャー"

# ポリモーフィズムの威力
def make_speak(animal: Animal):
    print(animal.speak())  # ←同じメソッド名で呼ぶだけ

make_speak(Dog())  # "ワン!"
make_speak(Cat())  # "ニャー"
```

「`speak()`を呼ぶ側は、相手が犬か猫か知らなくていい」というのがポイント。これが**抽象に依存する**ということ。

### なぜポリモーフィズムが必要なのか

**if文地獄からの解放**

```python
# ポリモーフィズムなし:新しい動物が増えるたびにif文追加
def make_speak(animal_type, animal):
    if animal_type == "dog":
        print("ワン!")
    elif animal_type == "cat":
        print("ニャー")
    elif animal_type == "bird":
        print("ピヨ!")
    # 新しい動物が増えるたびにここを修正…

# ポリモーフィズムあり:新しい動物クラスを作るだけ
def make_speak(animal: Animal):
    print(animal.speak())  # ←この関数は変更不要!
```

**開放閉鎖原則(OCP)**:「拡張に対しては開いているが、修正に対しては閉じている」を実現できる。

### ポリモーフィズムの種類(豆知識)

1. **サブタイプポリモーフィズム**:継承とオーバーライド(上の例)
2. **パラメトリックポリモーフィズム**:ジェネリクス(`List<T>`)
3. **アドホックポリモーフィズム**:メソッドオーバーロード

普段「ポリモーフィズム」と言うときは、たいてい1番目を指す。

### よくある勘違い

「ポリモーフィズム=継承」←**継承は手段の一つ**であって、本質ではない。インターフェースやダックタイピングでも実現できる。

### 使える一言

「Strategy パターンで決済方法の処理をポリモーフィズムで切り替えれば、新しい決済手段の追加がスムーズですね」←実務で使える知識

---

## デプリケート:「非推奨」と「廃止」の間で

### 雰囲気使用例

「このAPI、デプリケートされてるから使わない方がいいよ」

**質問:** じゃあもう使えないの?
**あなた:** いや…使えるけど…使わない方が…(違いが曖昧)

### 正しい理解

**デプリケート(Deprecate)**は「非推奨」という意味。**まだ使えるけど、将来削除される予定**であることを宣言する状態。

- **Deprecated(非推奨):**「もう使わないでね。でも今は動くよ」←今ここ
- **Removed(削除):**「もう使えないよ」←最終段階

```python
# Python の例
import warnings

def old_function():
    warnings.warn(
        "old_function is deprecated. Use new_function instead.",
        DeprecationWarning
    )
    # まだ動く
    return "old result"

def new_function():
    return "new result"
```

### デプリケートの段階的廃止プロセス

1. **非推奨を宣言:**ドキュメントに書く、ログに警告を出す
2. **移行期間を設ける:**ユーザーが新APIに移行できる時間を与える
3. **削除予告:**「バージョン3.0で削除します」と明言
4. **実際に削除:**本当に消える

このプロセスを踏まないと、いきなり消してユーザーを阿鼻叫喚に陥れることになる。

### なぜデプリケートするのか

- **より良い設計が見つかった**
- **セキュリティ上の問題がある**
- **保守コストが高すぎる**

### よくある混同

- **Deprecated ≠ Obsolete**
  - Deprecated:まだ動くけど使うな
  - Obsolete:古くなって使い物にならない(必ずしも削除予定とは限らない)

### 現場でのあるある

```
// 非推奨のAPIを使い続けるレガシーコード
function getUserData() {
    return $.ajax(...);  // jQuery、2025年でも現役(ただし非推奨)
}
```

「動いてるから直さなくていいでしょ」という判断と、「技術的負債が溜まる」という葛藤。デプリケートの警告は、この負債の利息請求書みたいなもの。

### 使える一言

「このライブラリの関数、デプリケートされてますね。次のメジャーバージョンアップで削除される前に、新しいAPIに移行しておきましょう」←計画的

---

## ペイロード:荷物の中身は何ですか?

### 雰囲気使用例

「このAPIのペイロードは…」

**質問:** ヘッダーとペイロードの違いは?
**あなた:** ペイロードは…本体…みたいな…?(曖昧)

### 正しい理解

**ペイロード(Payload)**は直訳すると「有償荷重」。航空業界の用語で、「お金を払ってもらって運ぶ荷物」のこと。つまり**本当に届けたい中身**。

ITの文脈では、**メタデータや制御情報を除いた、実際のデータ部分**を指す。

```http
POST /api/users
Headers:
  Content-Type: application/json  ←これはメタデータ
  Authorization: Bearer token123   ←これも制御情報

{  ←ここから下がペイロード
  "name": "太郎",
  "email": "taro@example.com"
}
```

「ヘッダーは封筒の宛先や切手、ペイロードは封筒の中身」みたいなイメージ。

### ペイロードの範囲は文脈で変わる

**HTTPの場合:**リクエスト/レスポンスのボディ部分がペイロード

**JWTの場合:**トークンの中の実データ部分

```
eyJhbGci...  ←ヘッダー
.eyJ1c2Vy...  ←ペイロード(ユーザーID、有効期限など)
.SflKxwRJ...  ←署名
```

**ネットワークパケットの場合:**TCPヘッダーを除いたデータ部分

### なぜペイロードという言葉を使うのか

「リクエストボディ」「データ部分」でもいいが、**プロトコルに依存しない抽象的な表現**として便利。HTTPでもgRPCでもMQTTでも「ペイロード」で通じる。

### よくある勘違い

「ペイロード=JSON」←**違います**。形式は問わない。XML、バイナリ、平文、なんでもペイロード。

### 使える一言

「ペイロードサイズが大きすぎるので、必要な項目だけに絞ってレスポンスを最適化しましょう」←パフォーマンス改善の視点

---

## エンドポイント:終点?いやAPIの窓口

### 雰囲気使用例

「このエンドポイントにリクエストを投げて…」

**質問:** エンドポイントとURLの違いは?
**あなた:** え…同じ…じゃないの…?(混乱)

### 正しい理解

**エンドポイント(Endpoint)**は「終点」という意味だが、ITでは**通信の接続先**を指す。

- **Web APIの場合:**特定の機能を提供するURL
  ```
  https://api.example.com/users        ←ユーザー一覧を取得するエンドポイント
  https://api.example.com/users/123    ←特定ユーザーを取得するエンドポイント
  ```

- **ネットワークの場合:**通信の末端(PCやサーバー)

- **AWS の場合:**サービスにアクセスするためのURL(VPCエンドポイントなど)

### なぜ「終点」なのか

通信データが旅をして、最終的に到達する場所だから。「起点(あなたのアプリ)」から「終点(API サーバー)」へデータが流れる。

```
[あなたのアプリ] ---(HTTPリクエスト)---> [https://api.example.com/users] ←エンドポイント
```

### エンドポイントとURLの違い

厳密には:

- **URL:**リソースの場所を示す文字列(Uniform Resource Locator)
- **エンドポイント:**APIの機能にアクセスするための入口(より概念的)

実務では「エンドポイントのURL」と言ったりして、ほぼ同義で使うことも多い。ただし、同じURLでも`GET`と`POST`で違う機能なら「別のエンドポイント」と見なすこともある(RESTの文脈)。

### REST APIとエンドポイント設計

```
GET    /users          ←ユーザー一覧
POST   /users          ←ユーザー作成
GET    /users/123      ←特定ユーザー取得
PUT    /users/123      ←特定ユーザー更新
DELETE /users/123      ←特定ユーザー削除
```

この設計思想で「エンドポイントはリソース(名詞)で表し、HTTPメソッドで動詞を表現する」というのがRESTの基本。

### よくある混同

「エンドポイント=関数」←APIの場合はそういう理解でもいいが、本質は「アクセス先」。

### 使える一言

「エンドポイントを`/getUserById`みたいな動詞にするより、`/users/:id`でHTTPメソッドで操作を表現した方がRESTfulですね」←設計レビューで光る

---

## スロットリング:アクセルを踏ませない技術

### 雰囲気使用例

「このAPI、スロットリングかかってるから注意して」

**質問:** レート制限と何が違うの?
**あなた:** え…同じ…?(本当に?)

### 正しい理解

**スロットリング(Throttling)**は「絞る」という意味。**処理速度や流量を制限する**こと。

- **APIの場合:**「1秒間に10リクエストまで」みたいに制限
- **ネットワークの場合:**帯域幅を制限
- **CPUの場合:**プロセスのCPU使用率を制限(サーマルスロットリングなど)

```python
# 簡易的なスロットリングの実装イメージ
import time

class Throttler:
    def __init__(self, max_calls, period):
        self.max_calls = max_calls  # 期間内の最大呼び出し回数
        self.period = period        # 期間(秒)
        self.calls = []

    def allow_request(self):
        now = time.time()
        # 古い記録を削除
        self.calls = [c for c in self.calls if c > now - self.period]

        if len(self.calls) < self.max_calls:
            self.calls.append(now)
            return True
        else:
            return False  # スロットリング発動!
```

### スロットリング vs レート制限(Rate Limiting)

実務ではほぼ同義で使われるが、微妙なニュアンスの違い:

- **レート制限:**「1分間に100リクエストまで」と回数を制限
- **スロットリング:**速度を絞る。「リクエストが多すぎたら遅くする(遅延を入れる)」

厳密に区別しない現場も多いが、**レート制限は超えたら拒否**、**スロットリングは超えたら遅延**というニュアンス。

### なぜスロットリングが必要なのか

**1. サーバー保護**

無限にリクエストを受け付けたら、サーバーがダウンする。DoS攻撃の防御にもなる。

**2. 公平性の確保**

一人のユーザーがAPIを占有しないように。みんなで仲良く使おうね、という思想。

**3. 課金プランの実現**

「フリープランは1時間100リクエスト、プレミアムは無制限」みたいなビジネスモデル。

### HTTP 429エラー:Too Many Requests

スロットリングに引っかかると、このエラーが返ってくる。

```http
HTTP/1.1 429 Too Many Requests
Retry-After: 60

{
  "error": "Rate limit exceeded. Try again in 60 seconds."
}
```

`Retry-After`ヘッダーで「いつ再試行していいか」を教えてくれる優しい設計。

### 実装パターン

- **トークンバケット:**バケツにトークンが溜まり、リクエストごとに消費
- **リーキーバケット:**バケツから水が一定速度で漏れ、溢れたら拒否
- **固定ウィンドウ:**「1分間に100回」を厳格に適用
- **スライディングウィンドウ:**直近60秒間で100回(より柔軟)

### よくある勘違い

「スロットリング=遅いAPI」←**違います**。制限に引っかからなければ普通に速い。乱用を防ぐための防御機構。

### 使える一言

「外部APIの呼び出しにスロットリングを実装して、予期せぬトラフィック急増からシステムを保護しましょう」←安定性重視の姿勢

---

## おわりに:設計レビューで恥をかかないための用語チェックリスト

最後に、今日学んだ用語で自分をチェックしよう。

### ✅ 設計レビュー前のセルフチェック

- [ ] **疎結合と密結合の違いを、依存性注入の例で説明できる**
- [ ] **ステートレスとステートフルの違いを、スケーラビリティの観点で語れる**
- [ ] **イミュータブルが並行処理で有利な理由を言える**
- [ ] **ポリモーフィズムの利点を、if文地獄との対比で説明できる**
- [ ] **デプリケートと削除の違い、移行プロセスを理解している**
- [ ] **ペイロードとヘッダーの違いを、具体例で示せる**
- [ ] **エンドポイントをRESTfulに設計できる**
- [ ] **スロットリングの実装方式を最低一つ説明できる**

全部にチェックが入ったら、あなたはもう「雰囲気で使ってる」側ではなく、**「ちゃんと理解して使ってる」側**だ。

### 最後に:完璧主義は捨てろ

ただし、忘れないでほしい。

**すべての用語を完璧に理解してから設計する必要はない**。

実際の現場では、「この設計で本当に疎結合になってる?」と悩みながら進めることの方が多い。大事なのは、**「なぜこの設計にしたのか」を説明できること**。

「ステートレスにしたのは、将来的に水平スケールしやすくするため」
「ここをイミュータブルにしたのは、Redux の設計思想に合わせるため」

こんな風に**理由を語れる**なら、それは雰囲気じゃなく、ちゃんとした設計判断だ。

用語は武器じゃなくて、**コミュニケーションツール**。チーム全員が同じ言葉で会話できるようになることが、本当のゴール。

さあ、次の設計レビューでは堂々と議論しよう。「それって具体的にどういうこと?」と聞かれても、もう大丈夫だ。
